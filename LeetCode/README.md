## Table of Contents
- [Table of Contents](#table-of-contents)
- [LeetCode 49: 字母异位词分组](#leetcode-49-字母异位词分组)
- [LeetCode 138: 随机链表的复制](#leetcode-138-随机链表的复制)
- [LeetCode 295: 数据流的中位数](#leetcode-295-数据流的中位数)
- [iFlytek 1: 动态删除中位数](#iflytek-1-动态删除中位数)
- [该搞这个了。](#该搞这个了)

---

## LeetCode 49: 字母异位词分组
[字母异位词分组](https://leetcode.cn/problems/group-anagrams/description/)

这个代码的主要思路是通过将每个单词排序后的结果作为键，将同一组字母的单词（即变位词）归类到一起。以下是具体步骤：

1. **创建一个默认字典**：`anagrams` 是一个默认字典（`defaultdict`），其默认值是一个空列表。这个字典用于存储排序后的单词作为键，原始单词列表作为值。
2. **遍历输入的单词列表**：
   - 对于每个单词，先对其字母进行排序。
   - 将排序后的单词作为键，原始单词作为值，添加到默认字典 `anagrams` 中。
3. **返回结果**：最终返回默认字典 `anagrams` 的所有值（即每个键对应的单词列表），它们是一个包含变位词的列表。

具体步骤如下：
1. 初始化一个默认字典 `anagrams`。
2. 遍历 `strs` 列表中的每个单词：
3. 将单词按字母顺序排序，得到一个新的排序后的字符串 `sorted_word`。
4. 使用 `sorted_word` 作为键，将原始单词添加到 `anagrams` 字典中相应的列表中。
5. 最后，将 `anagrams` 字典的所有值转换为一个列表返回。

通过这个过程，相同字母组成的单词（变位词）被归类到同一个列表中。

---

## LeetCode 138: 随机链表的复制
[随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/description/)

复制一个带有随机指针的链表（LeetCode 138）需要我们创建一个深拷贝的链表，每个节点不仅有一个 `next` 指针，还有一个 `random` 指针指向链表中的任意节点或 `None`。实现这个方法可以分为三个步骤：

1. **复制每个节点并将复制节点插入到原节点后面**：通过遍历原链表，我们创建一个新的节点，并将其插入到原节点后面。这样每个原节点后面紧跟一个复制节点。
2. **复制随机指针**：通过再次遍历链表，更新复制节点的 `random` 指针。
3. **拆分链表**：将复制节点从混合链表中拆分出来，恢复原链表并获得复制链表。

---



## LeetCode 295: 数据流的中位数
[数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/description/)

`__init__` 方法中，我们初始化两个堆：`self.small` 和 `self.large`。`self.small` 为最大堆，`self.large` 为最小堆。

`addNum` 方法中，我们首先将新的数字插入到最大堆中，为了模拟最大堆的行为，我们插入负值。
- 然后我们将最大堆的堆顶（最大值）插入最小堆。
- 如果最小堆的长度超过最大堆，我们将最小堆的堆顶（最小值）重新插入最大堆。

`findMedian` 方法中，我们根据两个堆的长度关系来决定中位数的计算方式：
- 如果两个堆的长度相等，中位数为两个堆顶的平均值。
- 否则，中位数为最大堆的堆顶（注意我们存储的是负值，所以要取反）。

这个方法保证了插入和查找中位数操作的时间复杂度都是 `O(logn)`。

---

## iFlytek 1: 动态删除中位数
该搞这个了。
---

