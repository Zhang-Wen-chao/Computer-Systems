笔试用Python写，保证正确。
## 数组 
### 977.有序数组的平方
两个指针往中间凑。每次比较两个指针所指向的数的平方，将较大的那个数的平方放入结果数组的相应位置，并移动相应的指针。
### 209.长度最小的子数组
两个指针维护滑动窗口。一个表示子数组的开始，另一个表示子数组的结束，并维护这两个指针之间的和。当当前和小于 s 时，增加结束指针；当当前和大于或等于 s 时，更新最小长度并增加开始指针。
### 59.螺旋矩阵II
顺时针的方向数组，模拟螺旋填充矩阵的过程。超出边界则，回退一步并改变方向。
## 链表
### 203.移除链表元素
两个指针遍历链表，统一使用dummy node。一个指针指向当前节点，另一个指针指向前一个节点。当当前节点的值与给定值相等时，我们更新前一个节点的 next 指针，从而跳过当前节点。如果当前节点是头节点并且其值与给定值相等，我们需要更新头节点。
### 206.翻转链表
核心思想是使用三个指针：prev, curr, 和 next。在遍历链表的过程中，我们将当前节点 curr 的 next 指针指向 prev，从而实现反转。然后，我们移动三个指针到下一个位置，直到整个链表被反转。
### 24.两两交换链表中的节点
这道题目要求将链表中的每两个相邻节点交换。例如，给定 1->2->3->4，你应该返回 2->1->4->3。

核心思想是使用三个指针：prev, first, 和 second。在每次迭代中，我们将 first 和 second 两个节点交换，并更新 prev 的 next 指针，然后移动三个指针到下一个位置。
### 19.删除链表的倒数第 N 个结点
这道题要求从链表的末尾删除第 n 个节点。一个常见的方法是使用两个指针，并使它们之间保持 n 个节点的距离，当后一个指针到达链表的末尾时，前一个指针将指向需要删除的节点的前一个节点。

核心思想是双指针技巧，具体步骤如下：

初始化两个指针 first 和 second，并将它们都指向头节点。
将 second 指针向前移动 n 个节点，从而使 first 和 second 之间保持 n 个节点的距离。
同时移动 first 和 second 指针，直到 second 指针到达链表的末尾。
此时，first 指针将指向需要删除的节点的前一个节点。我们可以通过更新 first 的 next 指针来删除节点。
### 面试题02.07.链表相交
双指针技巧

初始化两个指针 pA 和 pB，分别指向链表 A 和 B 的头节点。
同时移动两个指针，当 pA 到达链表 A 的末尾时，将其重定向到链表 B 的头节点；当 pB 到达链表 B 的末尾时，将其重定向到链表 A 的头节点。
如果两个链表相交，那么 pA 和 pB 将在交点处相遇；如果两个链表不相交，那么 pA 和 pB 将同时到达链表的末尾。
### 142.环形链表
快慢指针法，fast二倍速于slow。
如果链表中存在环，那么 fast 和 slow 指针最终会在环内的某个位置相遇。
当两个指针相遇时，将其中一个指针重新定位到链表的头部，并使两个指针都每次移动一个节点。当它们再次相遇时，相遇的位置即为环的起始节点。
## 哈希表
### 242.有效的字母异位词
核心思想是计数。我们可以使用一个数组或哈希表来计算每个字符在两个字符串中出现的次数。如果两个字符串是字母异位词，那么它们中的每个字符的出现次数都应该相同。
### 1002.查找常用字符
这道题的核心思想是统计每个单词中每个字符的出现次数，并找出所有单词中共同的字符及其最小出现次数。

初始化一个数组 minFreq，大小为26（代表26个字母），并将其所有元素设置为正无穷大。这个数组用于存储所有单词中每个字符的最小出现次数。
对于每个单词，统计该单词中每个字符的出现次数，存储在 freq 数组中。
更新 minFreq 数组，将其与 freq 数组中的每个元素进行比较，取较小值。
根据 minFreq 数组构建结果列表。
### 349.两个数组的交集
使用哈希集合（unordered_set）来存储第一个数组中的所有元素。
遍历第二个数组，检查每个元素是否存在于哈希集合中。
如果存在，则将该元素添加到结果集合中，并从哈希集合中删除，以避免重复添加。
最后，将结果集合转换为数组并返回。
### 202.快乐数
使用一个函数来计算每位数字的平方和。
使用快慢指针技巧来检测是否存在循环。这是因为，如果一个数不是快乐数，那么计算其每位数字的平方和的过程会进入一个循环。
如果快指针最终等于 1，则返回 true；否则，如果快慢指针相遇，则返回 false。
### 1.两数之和
使用哈希表（unordered_map）来存储数组中的每个元素及其索引。
遍历数组，对于每个元素 nums[i]，计算 target - nums[i]，并检查这个差值是否存在于哈希表中。
如果存在，并且其索引不等于 i，则返回这两个索引。
### 454.四数相加II
利用哈希表（unordered_map）将问题从四数之和简化为两数之和。
具体地，我们可以计算数组A和B中所有可能的两数之和，并将和存储在哈希表中，其中键是和，值是该和出现的次数。
然后，我们计算数组C和D中所有可能的两数之和，对于每个和，我们检查其相反数是否存在于哈希表中。如果存在，那么就找到了一个满足条件的四元组。
### 383.赎金信
这道题目要求判断是否可以从杂志字符串中构造赎金信字符串，其中每个字符只能使用一次。
使用哈希表（通常选择unordered_map）来统计杂志字符串中每个字符的出现次数。
遍历赎金信字符串，对于每个字符，检查它是否存在于哈希表中，并且出现次数大于0。如果是，则减少该字符在哈希表中的计数；否则，返回false。
如果赎金信字符串中的所有字符都满足上述条件，则返回true。
### 15.三数之和
这道题目要求找到数组中所有的三元组，使得它们的和为0，并返回所有不重复的三元组。

先对数组进行排序。
使用固定的指针遍历数组，然后使用双指针技巧在当前固定指针的右侧寻找两个数，使得它们的和为0减去当前固定指针的值。
为了避免重复的三元组，需要跳过重复的值。
### 18.四数之和
这道题目要求找到数组中所有的四元组，使得它们的和为一个给定的目标值，并返回所有不重复的四元组。

先对数组进行排序。
使用两层固定的指针遍历数组，然后在这两个固定指针的右侧使用双指针技巧来寻找两个数，使得它们的和为目标值减去这两个固定指针的值。
为了避免重复的四元组，需要跳过重复的值。
## 字符串
### 344.反转字符串
使用双指针技巧，一个指针从数组的开始位置开始，另一个指针从数组的结束位置开始。
交换两个指针所指向的字符，然后移动指针，直到两个指针相遇或交叉。
### 541.反转字符串II
这道题目要求每隔 k 个字符反转前 k 个字符。如果剩余字符少于 k 个，则反转所有剩余字符。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持不变。

核心思想：
使用一个循环，每次迭代的步长为 2k，因为每次我们只处理 2k 个字符。
在每次迭代中，我们反转从 i 开始的前 k 个字符。这可以通过双指针技巧实现，其中一个指针指向开始位置，另一个指针指向结束位置。
### 替换空格
创建一个新的字符串 result，然后遍历原始字符串 str，对于每个字符，如果它是空格，就向 result 中添加"%20"；否则，直接添加该字符。
### 151.翻转字符串里的单词
这个算法的核心思想是反转字符串中的单词顺序，而不是字符的顺序。具体来说，它的步骤如下：

分割字符串为单词：使用std::istringstream和>>操作符，将输入的字符串str按照空格分割为单词，并将这些单词存储在`std::vector<std::string>`中。

反转单词的顺序：使用std::reverse函数，将存储在向量中的单词的顺序反转。

拼接反转后的单词：遍历反转后的单词向量，并将每个单词拼接到结果字符串result中。每个单词后都添加一个空格。

去除末尾的空格：由于在拼接单词时，每个单词后都添加了一个空格，所以最后的结果字符串的末尾会有一个多余的空格。使用result.pop_back()方法去除这个多余的空格。

返回结果：返回处理后的字符串result。
### 左旋转字符串
```cpp
std::string reverseLeftWords(std::string str, int n) {
    std::rotate(str.begin(), str.begin() + n, str.end());
    return str;
}
```
### 459.重复的子字符串
```cpp
bool repeatedSubstringPattern(std::string s) {
    return (s + s).substr(1, 2 * s.size() - 2).find(s) != std::string::npos;
}
```
## 栈与队列
### 232.用栈实现队列
核心思想是使用两个栈，一个用于插入（inStack），另一个用于删除和查看队列的前端（outStack）。
### 225.用队列实现栈
核心思想是使用两个队列，一个主队列（称为mainQueue）和一个辅助队列（称为auxQueue）。
Push操作：当我们要向栈中添加一个元素时，我们首先将新元素添加到auxQueue，然后将mainQueue中的所有元素依次出队并入队到auxQueue。最后，我们交换mainQueue和auxQueue的角色。这样，新添加的元素总是位于mainQueue的前端，从而实现了栈的LIFO（后进先出）特性。

Pop操作：我们只需从mainQueue中出队一个元素。

Top操作：我们只需查看mainQueue的前端元素。

Empty操作：栈为空当且仅当mainQueue为空。
### 20.有效的括号
核心思想是使用一个栈来跟踪尚未匹配的开括号。当我们遇到一个闭括号时，我们检查栈的顶部元素是否是相应的开括号。如果是，我们弹出栈的顶部元素；如果不是，字符串无效。
### 1047.删除字符串中的所有相邻重复项
核心思想是使用一个栈来跟踪结果字符串中的字符。当我们遇到一个字符时，我们检查它是否与栈的顶部字符相同。如果相同，这意味着它们是相邻的重复字符，所以我们弹出栈的顶部字符；如果不同，我们将当前字符推入栈。
### 150.逆波兰表达式求值
核心思想是使用一个栈来跟踪操作数。当我们遇到一个运算符时，我们从栈中弹出所需数量的操作数，执行运算，然后将结果推回栈中。
### 239.滑动窗口最大值
这个还是挺难懂的，我还没看明白。

核心思想是使用一个双端队列（deque）来跟踪当前窗口中的元素，并确保队列的前端始终包含窗口的最大值。队列中存储的是元素的索引，而不是元素本身。

初始化一个空的双端队列：这个队列将用于跟踪当前窗口中的元素。

遍历数组：对于数组中的每个元素，执行以下操作：

移除队列中所有小于当前元素的元素，因为它们不可能是当前或任何后续窗口的最大值。
如果队列的前端元素（即当前窗口的最大值）已经不在窗口中（索引差大于或等于k），则从队列中移除它。
将当前元素的索引推入队列的后端。
如果我们已经遍历了至少k个元素，那么队列的前端元素就是当前窗口的最大值。
返回结果：构建一个结果数组，其中每个元素是相应窗口的最大值。
### 347.前K个高频元素
核心思想是使用哈希表来跟踪每个元素的频率，然后使用优先队列（或称为堆）来找到出现频率最高的k个元素。

以下是具体的实现策略：

使用哈希表跟踪频率：遍历数组，使用哈希表（例如std::unordered_map）来跟踪每个元素的出现频率。

使用优先队列找到前k个高频元素：基于元素的出现频率，使用一个优先队列来找到出现频率最高的k个元素。优先队列可以根据元素的频率进行排序。
```cpp
std::priority_queue<std::pair<int, int>> pq;
for (const auto& [num, freq] : frequency) {
    pq.push({freq, num});
}
```
返回结果：从优先队列中提取前k个元素。
## 二叉树 
### 二叉树的递归遍历

### 二叉树的迭代遍历
#### 二叉树的前序遍历
使用一个栈来模拟前序遍历的过程。首先，将根节点入栈，然后进入循环，直到栈为空。在循环中，首先将栈顶节点出栈并访问它（将节点值添加到结果数组中）。然后，将右子树（如果存在）入栈，再将左子树（如果存在）入栈。这样可以保证左子树在右子树之前被访问，从而实现前序遍历的顺序。
#### 二叉树的中序遍历
让我解释一下这段代码的逻辑：

首先，定义了一个std::vector<T>类型的result，用于存储中序遍历的结果。
创建一个std::stack<TreeNode<T>*>类型的栈stk，用于辅助进行中序遍历。
进入一个循环，条件是root不为空或者栈不为空。这个循环用于遍历二叉树。
在循环中，首先检查root是否为空。如果root不为空，就表示还有左子树节点需要访问。此时，将当前的root节点入栈，并将root指针移动到左子树节点，以便后续遍历左子树。
如果root为空，说明左子树已经遍历完毕或者没有左子树，此时从栈中弹出一个节点，将其值添加到result中，并将root指针移动到弹出节点的右子树节点，以便后续遍历右子树。
重复步骤4和5，直到遍历完整棵二叉树。
这种迭代方法使用栈来模拟递归过程，以确保按照中序遍历的顺序访问二叉树的节点。最终，result中将包含按中序遍历顺序排列的节点值，它是函数的返回值。这种方法避免了递归，节省了函数调用栈的空间，并在不增加额外数据结构的情况下实现了中序遍历。
#### 二叉树的后序遍历
首先，定义了一个std::vector<T>类型的result，用于存储后序遍历的结果。
创建一个std::stack<TreeNode<T>*>类型的栈stk，用于辅助进行后序遍历。
初始化两个指针变量 curr 和 lastVisited，分别用于追踪当前遍历的节点和上次访问的节点。初始时，将 curr 设置为根节点 root，lastVisited 设置为 nullptr。
然后进入一个循环，条件是curr不为空或者栈不为空。这个循环用于遍历二叉树。

在循环中，首先使用一个内部的 while 循环将 curr 及其左子树的左节点依次入栈，一直走到左子树的最左边叶子节点。这个操作确保了后续遍历的左子树部分被入栈。

然后，检查栈顶元素，即 stk.top()，赋值给 top 变量。此时，需要检查右子树是否已经访问过或者右子树为空。

如果右子树为空（top->right == nullptr），或者右子树已经访问过（top->right == lastVisited），说明可以访问当前节点了。此时，将栈顶节点出栈（stk.pop()），将当前节点的值添加到result中（result.push_back(top->val)），并将 lastVisited 更新为当前节点 top。这表示当前节点的左子树和右子树都已经访问完毕，可以访问当前节点了。

如果右子树不为空且未访问过，说明需要继续处理右子树，将 curr 更新为 top->right，以便后续遍历右子树。

重复步骤4和5，直到遍历完整棵二叉树。

这种迭代方法使用栈来模拟递归过程，以确保按照后序遍历的顺序访问二叉树的节点。最终，result中将包含按后序遍历顺序排列的节点值，它是函数的返回值。这种方法避免了递归，节省了函数调用栈的空间，并在不增加额外数据结构的情况下实现了后序遍历。
### 二叉树的统一迭代法
### 二叉树的层序遍历
### 226.翻转二叉树
###

这道题用cpp怎么写？核心思想是什么？

8. [二叉树：101.对称二叉树](./problems/0101.对称二叉树.md)
9. [二叉树：104.二叉树的最大深度](./problems/0104.二叉树的最大深度.md)
10. [二叉树：111.二叉树的最小深度](./problems/0111.二叉树的最小深度.md)
11. [二叉树：222.完全二叉树的节点个数](./problems/0222.完全二叉树的节点个数.md)
12. [二叉树：110.平衡二叉树](./problems/0110.平衡二叉树.md)
13. [二叉树：257.二叉树的所有路径](./problems/0257.二叉树的所有路径.md)
14. [本周总结！（二叉树）](./problems/周总结/20201003二叉树周末总结.md)
15. [二叉树：二叉树中递归带着回溯](./problems/二叉树中递归带着回溯.md)
16. [二叉树：404.左叶子之和](./problems/0404.左叶子之和.md)
17. [二叉树：513.找树左下角的值](./problems/0513.找树左下角的值.md)
18. [二叉树：112.路径总和](./problems/0112.路径总和.md)
19. [二叉树：106.构造二叉树](./problems/0106.从中序与后序遍历序列构造二叉树.md)
20. [二叉树：654.最大二叉树](./problems/0654.最大二叉树.md)
21. [本周小结！（二叉树）](./problems/周总结/20201010二叉树周末总结.md) 
22. [二叉树：617.合并两个二叉树](./problems/0617.合并二叉树.md)
23. [二叉树：700.二叉搜索树登场！](./problems/0700.二叉搜索树中的搜索.md)
24. [二叉树：98.验证二叉搜索树](./problems/0098.验证二叉搜索树.md)
25. [二叉树：530.搜索树的最小绝对差](./problems/0530.二叉搜索树的最小绝对差.md)
26. [二叉树：501.二叉搜索树中的众数](./problems/0501.二叉搜索树中的众数.md)
27. [二叉树：236.公共祖先问题](./problems/0236.二叉树的最近公共祖先.md)
28. [本周小结！（二叉树）](./problems/周总结/20201017二叉树周末总结.md)
29. [二叉树：235.搜索树的最近公共祖先](./problems/0235.二叉搜索树的最近公共祖先.md)
30. [二叉树：701.搜索树中的插入操作](./problems/0701.二叉搜索树中的插入操作.md)
31. [二叉树：450.搜索树中的删除操作](./problems/0450.删除二叉搜索树中的节点.md)
32. [二叉树：669.修剪二叉搜索树](./problems/0669.修剪二叉搜索树.md)
33. [二叉树：108.将有序数组转换为二叉搜索树](./problems/0108.将有序数组转换为二叉搜索树.md)
34. [二叉树：538.把二叉搜索树转换为累加树](./problems/0538.把二叉搜索树转换为累加树.md)
35. [二叉树：总结篇！（需要掌握的二叉树技能都在这里了）](./problems/二叉树总结篇.md)

###
###
###
###
###
###
###
###
###
###
###
###
###
###
###






## 回溯算法 

题目分类大纲如下：             

<img src='https://img-blog.csdnimg.cn/20210219192050666.png' width=600 alt='回溯算法大纲'> </img></div>

1. [关于回溯算法，你该了解这些！](./problems/回溯算法理论基础.md)
2. [回溯算法：77.组合](./problems/0077.组合.md)
3. [回溯算法：77.组合优化](./problems/0077.组合优化.md)
4. [回溯算法：216.组合总和III](./problems/0216.组合总和III.md)
5. [回溯算法：17.电话号码的字母组合](./problems/0017.电话号码的字母组合.md)
6. [本周小结！（回溯算法系列一）](./problems/周总结/20201030回溯周末总结.md)
7. [回溯算法：39.组合总和](./problems/0039.组合总和.md)
8. [回溯算法：40.组合总和II](./problems/0040.组合总和II.md)
9. [回溯算法：131.分割回文串](./problems/0131.分割回文串.md)
10. [回溯算法：93.复原IP地址](./problems/0093.复原IP地址.md)
11. [回溯算法：78.子集](./problems/0078.子集.md)
12. [本周小结！（回溯算法系列二）](./problems/周总结/20201107回溯周末总结.md)
13. [回溯算法：90.子集II](./problems/0090.子集II.md)
14. [回溯算法：491.递增子序列](./problems/0491.递增子序列.md)
15. [回溯算法：46.全排列](./problems/0046.全排列.md)
16. [回溯算法：47.全排列II](./problems/0047.全排列II.md)
17. [本周小结！（回溯算法系列三）](./problems/周总结/20201112回溯周末总结.md)
18. [回溯算法去重问题的另一种写法](./problems/回溯算法去重问题的另一种写法.md)
19. [回溯算法：332.重新安排行程](./problems/0332.重新安排行程.md)
20. [回溯算法：51.N皇后](./problems/0051.N皇后.md)
21. [回溯算法：37.解数独](./problems/0037.解数独.md)
22. [回溯算法总结篇](./problems/回溯总结.md)

## 贪心算法 

题目分类大纲如下：             


<img src='https://code-thinking-1253855093.file.myqcloud.com/pics/20210917104315.png' width=600 alt='贪心算法大纲'> </img></div>

1. [关于贪心算法，你该了解这些！](./problems/贪心算法理论基础.md)
2. [贪心算法：455.分发饼干](./problems/0455.分发饼干.md)
3. [贪心算法：376.摆动序列](./problems/0376.摆动序列.md)
4. [贪心算法：53.最大子序和](./problems/0053.最大子序和.md)
5. [本周小结！（贪心算法系列一）](./problems/周总结/20201126贪心周末总结.md)
6. [贪心算法：122.买卖股票的最佳时机II](./problems/0122.买卖股票的最佳时机II.md)
7. [贪心算法：55.跳跃游戏](./problems/0055.跳跃游戏.md)
8. [贪心算法：45.跳跃游戏II](./problems/0045.跳跃游戏II.md)
9. [贪心算法：1005.K次取反后最大化的数组和](./problems/1005.K次取反后最大化的数组和.md)
10. [本周小结！（贪心算法系列二）](./problems/周总结/20201203贪心周末总结.md)
11. [贪心算法：134.加油站](./problems/0134.加油站.md)
12. [贪心算法：135.分发糖果](./problems/0135.分发糖果.md)
13. [贪心算法：860.柠檬水找零](./problems/0860.柠檬水找零.md)
14. [贪心算法：406.根据身高重建队列](./problems/0406.根据身高重建队列.md)
15. [本周小结！（贪心算法系列三）](./problems/周总结/20201217贪心周末总结.md)
16. [贪心算法：406.根据身高重建队列（续集）](./problems/根据身高重建队列（vector原理讲解）.md)
17. [贪心算法：452.用最少数量的箭引爆气球](./problems/0452.用最少数量的箭引爆气球.md)
18. [贪心算法：435.无重叠区间](./problems/0435.无重叠区间.md)
19. [贪心算法：763.划分字母区间](./problems/0763.划分字母区间.md)
20. [贪心算法：56.合并区间](./problems/0056.合并区间.md)
21. [本周小结！（贪心算法系列四）](./problems/周总结/20201224贪心周末总结.md)
22. [贪心算法：738.单调递增的数字](./problems/0738.单调递增的数字.md)
23. [贪心算法：968.监控二叉树](./problems/0968.监控二叉树.md)
24. [贪心算法：总结篇！（每逢总结必经典）](./problems/贪心算法总结篇.md)

## 动态规划

动态规划专题已经开始啦，来不及解释了，小伙伴们上车别掉队！

<img src='https://code-thinking.cdn.bcebos.com/pics/动态规划-总结大纲1.jpg' width=500> </img></div>
1. [关于动态规划，你该了解这些！](./problems/动态规划理论基础.md)
2. [动态规划：509.斐波那契数](./problems/0509.斐波那契数.md)
3. [动态规划：70.爬楼梯](./problems/0070.爬楼梯.md)
4. [动态规划：746.使用最小花费爬楼梯](./problems/0746.使用最小花费爬楼梯.md)
5. [本周小结！（动态规划系列一）](./problems/周总结/20210107动规周末总结.md)
6. [动态规划：62.不同路径](./problems/0062.不同路径.md)
7. [动态规划：63.不同路径II](./problems/0063.不同路径II.md)
8. [动态规划：343.整数拆分](./problems/0343.整数拆分.md)
9. [动态规划：96.不同的二叉搜索树](./problems/0096.不同的二叉搜索树.md)
10. [本周小结！（动态规划系列二）](./problems/周总结/20210114动规周末总结.md)

背包问题系列：

<img src='https://code-thinking.cdn.bcebos.com/pics/动态规划-背包问题总结.png' width=500 alt='背包问题大纲'> </img></div>


11. [动态规划：01背包理论基础](./problems/背包理论基础01背包-1.md)
12. [动态规划：01背包理论基础（滚动数组）](./problems/背包理论基础01背包-2.md)
13. [动态规划：416.分割等和子集](./problems/0416.分割等和子集.md)
14. [动态规划：1049.最后一块石头的重量II](./problems/1049.最后一块石头的重量II.md)
15. [本周小结！（动态规划系列三）](./problems/周总结/20210121动规周末总结.md)
16. [动态规划：494.目标和](./problems/0494.目标和.md)
17. [动态规划：474.一和零](./problems/0474.一和零.md) 
18. [动态规划：完全背包总结篇](./problems/背包问题理论基础完全背包.md)
19. [动态规划：518.零钱兑换II](./problems/0518.零钱兑换II.md)
20. [本周小结！（动态规划系列四）](./problems/周总结/20210128动规周末总结.md)
21. [动态规划：377.组合总和Ⅳ](./problems/0377.组合总和Ⅳ.md)
22. [动态规划：70.爬楼梯（完全背包版本）](./problems/0070.爬楼梯完全背包版本.md)
23. [动态规划：322.零钱兑换](./problems/0322.零钱兑换.md)
24. [动态规划：279.完全平方数](./problems/0279.完全平方数.md)
25. [本周小结！（动态规划系列五）](./problems/周总结/20210204动规周末总结.md)
26. [动态规划：139.单词拆分](./problems/0139.单词拆分.md)
27. [动态规划：多重背包理论基础](./problems/背包问题理论基础多重背包.md)
28. [背包问题总结篇](./problems/背包总结篇.md)

打家劫舍系列：

29. [动态规划：198.打家劫舍](./problems/0198.打家劫舍.md)
30. [动态规划：213.打家劫舍II](./problems/0213.打家劫舍II.md)
31. [动态规划：337.打家劫舍III](./problems/0337.打家劫舍III.md)

股票系列：

<img src='https://code-thinking.cdn.bcebos.com/pics/股票问题总结.jpg' width=500 alt='股票问题总结'> </img></div>


32. [动态规划：121.买卖股票的最佳时机](./problems/0121.买卖股票的最佳时机.md)
33. [动态规划：本周小结（系列六）](./problems/周总结/20210225动规周末总结.md)
34. [动态规划：122.买卖股票的最佳时机II](./problems/0122.买卖股票的最佳时机II（动态规划）.md)
35. [动态规划：123.买卖股票的最佳时机III](./problems/0123.买卖股票的最佳时机III.md)
36. [动态规划：188.买卖股票的最佳时机IV](./problems/0188.买卖股票的最佳时机IV.md)
37. [动态规划：309.最佳买卖股票时机含冷冻期](./problems/0309.最佳买卖股票时机含冷冻期.md)
38. [动态规划：本周小结（系列七）](./problems/周总结/20210304动规周末总结.md)
39. [动态规划：714.买卖股票的最佳时机含手续费](./problems/0714.买卖股票的最佳时机含手续费（动态规划）.md)
40. [动态规划：股票系列总结篇](./problems/动态规划-股票问题总结篇.md)

子序列系列： 

<img src='https://code-thinking.cdn.bcebos.com/pics/动态规划-子序列问题总结.jpg' width=500 alt=''> </img></div>


41. [动态规划：300.最长递增子序列](./problems/0300.最长上升子序列.md)
42. [动态规划：674.最长连续递增序列](./problems/0674.最长连续递增序列.md)
43. [动态规划：718.最长重复子数组](./problems/0718.最长重复子数组.md)
44. [动态规划：1143.最长公共子序列](./problems/1143.最长公共子序列.md)
45. [动态规划：1035.不相交的线](./problems/1035.不相交的线.md)
46. [动态规划：53.最大子序和](./problems/0053.最大子序和（动态规划）.md)
47. [动态规划：392.判断子序列](./problems/0392.判断子序列.md)
48. [动态规划：115.不同的子序列](./problems/0115.不同的子序列.md)
49. [动态规划：583.两个字符串的删除操作](./problems/0583.两个字符串的删除操作.md)
50. [动态规划：72.编辑距离](./problems/0072.编辑距离.md)
51. [编辑距离总结篇](./problems/为了绝杀编辑距离，卡尔做了三步铺垫.md)
52. [动态规划：647.回文子串](./problems/0647.回文子串.md)
53. [动态规划：516.最长回文子序列](./problems/0516.最长回文子序列.md)
54. [动态规划总结篇](./problems/动态规划总结篇.md)


## 单调栈 

1. [单调栈：739.每日温度](./problems/0739.每日温度.md)
2. [单调栈：496.下一个更大元素I](./problems/0496.下一个更大元素I.md)
3. [单调栈：503.下一个更大元素II](./problems/0503.下一个更大元素II.md)
4. [单调栈：42.接雨水](./problems/0042.接雨水.md)
5. [单调栈：84.柱状图中最大的矩形](./problems/0084.柱状图中最大的矩形.md)


## 图论 

通知：开始更新图论内容，图论部分还没有其他语言版本，欢迎录友们提交PR，成为contributor

### 深搜广搜  

* [图论：深度优先搜索理论基础](./problems/图论深搜理论基础.md)
* [图论：797.所有可能的路径](./problems/0797.所有可能的路径.md)
* [图论：广度优先搜索理论基础](./problems/图论广搜理论基础.md)
* [图论：200.岛屿数量.深搜版](./problems/0200.岛屿数量.深搜版.md)
* [图论：200.岛屿数量.广搜版](./problems/0200.岛屿数量.广搜版.md)
* [图论：695.岛屿的最大面积](./problems/0695.岛屿的最大面积.md)
* [图论：1020.飞地的数量](./problems/1020.飞地的数量.md)
* [图论：130.被围绕的区域](./problems/0130.被围绕的区域.md)
* [图论：417.太平洋大西洋水流问题](./problems/0417.太平洋大西洋水流问题.md)
* [图论：827.最大人工岛](./problems/0827.最大人工岛.md)
* [图论：127. 单词接龙](./problems/0127.单词接龙.md)
* [图论：841.钥匙和房间](./problems/841.钥匙和房间)
* [图论：463. 岛屿的周长](./problems/0463.岛屿的周长.md)
* [图论：并查集理论基础](./problems/)
* [图论：1971. 寻找图中是否存在路径](./problems/1971.寻找图中是否存在路径.md)
* [图论：684.冗余连接](./problems/0684.冗余连接.md)
* [图论：685.冗余连接II](./problems/0685.冗余连接II.md)